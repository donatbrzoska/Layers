#include "../ShaderBase/shader_base.hlsl"

#include "../Paint/paint.hlsl"
#include "../paint_grid.hlsl"

RWStructuredBuffer<ColumnInfo> ReservoirInfoDuplicate;
int3 ReservoirSize;

int2 ReduceRegionSize;
int ReduceFunction;


#pragma kernel reduce_volume

// assumes that index_base always has always smaller values than index
int in_reduce_bounds(int2 index, int2 index_base)
{
    // casting to int2 and do abs(), because CalculationPosition may be negative
    return int(all(abs(int2(index) - CalculationPosition) < int2(ReduceRegionSize)));
}

[numthreads(32,1,1)]
void reduce_volume(int3 id_ : SV_DispatchThreadID)
{
    id__ = id_;
    if (is_relevant_thread(id(), CalculationSize))
    {
        int2 upper = int2(0, CalculationSize.y);
        int2 right = int2(CalculationSize.x, 0);

        int2 i_base = CalculationPosition + id();
        int2 i_ll = i_base;
        int2 i_lr = i_base + right;
        int2 i_ul = i_base + upper;
        int2 i_ur = i_base + right + upper;

        float value_ll = ReservoirInfoDuplicate[XY(i_ll.x, i_ll.y, ReservoirSize.x)].volume * in_reduce_bounds(i_ll, i_base);
        float value_lr = ReservoirInfoDuplicate[XY(i_lr.x, i_lr.y, ReservoirSize.x)].volume * in_reduce_bounds(i_lr, i_base);
        float value_ul = ReservoirInfoDuplicate[XY(i_ul.x, i_ul.y, ReservoirSize.x)].volume * in_reduce_bounds(i_ul, i_base);
        float value_ur = ReservoirInfoDuplicate[XY(i_ur.x, i_ur.y, ReservoirSize.x)].volume * in_reduce_bounds(i_ur, i_base);

        float result = 0;
        if (ReduceFunction == 0) // max
        {
            result = max(max(max(value_ll, value_lr), value_ul), value_ur);
        }
        else if (ReduceFunction == 1) // add
        {
            result = value_ll + value_lr + value_ul + value_ur;
        }
        ReservoirInfoDuplicate[XY(i_ll.x, i_ll.y, ReservoirSize.x)].volume = result;
    }
}