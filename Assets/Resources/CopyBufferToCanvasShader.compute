// ######################################## SHADER BASE ########################################

#pragma kernel main

#include "basic_util.hlsl"
#include "index_util.hlsl"
#include "log_util.hlsl"

uint3 id;

// Filter #1
uint2 CalculationSize;

RWStructuredBuffer<float4> Debug;
RWStructuredBuffer<int> DebugType;

void set_debug_type(int t)
{
    DebugType[0] = t;
}

void log_(float4 f)
{
    Debug[XY(id.x, id.y, CalculationSize.x)] = f;
}

// ###################################### SHADER BASE END ######################################

#include "paint.hlsl"

int2 CalculationPosition;

RWStructuredBuffer<Paint> RakelEmittedPaint;

RWStructuredBuffer<Paint> CanvasReservoir;
uint TextureWidth;

// RWStructuredBuffer<int> Finished;


[numthreads(1,8,1)]
void main (uint3 id : SV_DispatchThreadID)
{
    // Filter #1
    if (is_relevant_thread(id, CalculationSize))
    {
        // calculate pixel position on canvas
        int2 canvas_pixel = id.xy + CalculationPosition;


        // // ### SMOOTH
        // uint kernel_size = 3;
        // int radius = (kernel_size-1)/2;

        // int volume = 0;
        // for (int i=-radius; i<=radius; i++) {
        //     for (int j=-radius; j<=radius; j++) {
        //         // ... deal with oob access // TODO this generates volume at the borders, doesn't it?
        //         uint x = clamp(id.x + i, 0, CalculationSize.x-1);
        //         uint y = clamp(id.y + j, 0, CalculationSize.y-1);
        //         volume += RakelEmittedPaint[XY(x, y, CalculationSize.x)].volume;
        //     }
        // }
        // // volume = volume * 0.04; // == /25
        // volume = int(float(volume) / float(kernel_size*kernel_size));

        // // Create and put smoothed volume to z=1
        // Paint p;
        // p.color = RakelEmittedPaint[XY(id.x, id.y, CalculationSize.x)].color;
        // p.volume = volume;


        // ### COPY
        // get emitted paint
        // .. in this case CalculationSize == ReservoirSize
        Paint emitted = RakelEmittedPaint[XY(id.x, id.y, CalculationSize.x)];
        Paint on_canvas = CanvasReservoir[XY(canvas_pixel.x, canvas_pixel.y, TextureWidth)];
        Paint mixed = mix(emitted, on_canvas);

        CanvasReservoir[XY(canvas_pixel.x, canvas_pixel.y, TextureWidth)] = mixed;
    }
    // if (id.x == 0 && id.y == 0)
    // {
    //     Finished[0] = 1;
    // }
}