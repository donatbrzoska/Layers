#include "../ShaderBase/shader_base.hlsl"

#include "../distance.hlsl"
#include "../convert.hlsl"
#include "../Paint/paint.hlsl"
#include "../math.hlsl"
#include "../rakel.hlsl"
#include "../mapped_info.hlsl"

uint TextureResolution;

float3 CanvasPosition;
float2 CanvasSize;

RWStructuredBuffer<Rakel> RakelInfo;
uint2 RakelReservoirSize;

RWStructuredBuffer<MappedInfo> RakelMappedInfo;


// returns:
// - x: exact projection of canvas pixel.x to rakel reservoir index space
// - y: exact projection of canvas pixel.y to rakel reservoir index space
// - z: distance from rakel: -inf .. +inf
MappedInfo rakel_mapped(int2 pos_pixel)
{
    Rakel rakel = RakelInfo[0];

    // translate pixel to world space
    float3 pos_world_space = pixel_to_world_space(pos_pixel, TextureResolution, CanvasPosition, CanvasSize);

    // translate back so pixel is anchor aligned
    float3 back_translation_position = rakel.anchor - float3(rakel.position.x, rakel.position.y, 0);
    float3 pos_back_translated_position = pos_world_space + back_translation_position;

    // rotate back around anchor
    float3 pos_back_rotated = rotate_by_z(pos_back_translated_position, - rakel.rotation, rakel.anchor);

    // calculate results
    float rakel_tilted_x_max = rakel.lr_tilted.x;
    float rakel_tilted_x_min = rakel.ll_tilted.x;
    float rakel_tilted_dx = rakel_tilted_x_max - rakel_tilted_x_min;
    float part_x = (pos_back_rotated.x - rakel_tilted_x_min) / rakel_tilted_dx;
    float part_y = pos_back_rotated.y / rakel.length; // currently easy, because there is no length tilt

    float dist = distance_from_rakel(pos_back_rotated, rakel.ll_tilted, rakel.lr_tilted, float3(rakel.anchor.x, rakel.anchor.y, rakel.position.z));
    
    // NOTE: this calculation does not work for a curved rakel
    // part_x 0 means actually left from the pixel center, because the part_ info is about world space
    // reservoir_pixel is -0.5 for part_k == 0 and RakelReservoirSize.k - 1 + 0.5 for part_k == 1
    float2 reservoir_pixel = float2(part_x * RakelReservoirSize.x - 0.5,
                                    part_y * RakelReservoirSize.y - 0.5);

    MappedInfo mapped_info;
    mapped_info.reservoir_pixel = reservoir_pixel;
    mapped_info.distance = dist;
    return mapped_info;
}

#pragma kernel main

[numthreads(32,1,1)]
void main (uint3 id_ : SV_DispatchThreadID)
{
    id__ = id_;
    if (is_relevant_thread(id(), CalculationSize))
    {
        // calculate pixel position on canvas
        // was uint2 before, but negative values are possible due to padding and no prevention of that because it should not cause any more problems
        int2 canvas_pixel = id() + CalculationPosition;

        RakelMappedInfo[XY(id().x, id().y, CalculationSize.x)] = rakel_mapped(canvas_pixel);
    }
}