// ######################################## SHADER BASE ########################################

#include "basic_util.hlsl"
#include "indexing.hlsl"
#include "logging.hlsl"

uint3 id__;
uint2 SubgridGroupSize;
uint2 SubgridCurrentThreadID;

uint2 id()
{
    uint2 subgrid_id = uint2(id__.x, id__.y);
    return subgrid_id * SubgridGroupSize + SubgridCurrentThreadID;
}

int2 CalculationPosition;
uint2 CalculationSize;

RWStructuredBuffer<float4> Debug;
RWStructuredBuffer<DebugListInfo> DebugInfo;

void set_debug_list_info(uint size, uint t)
{
    DebugListInfo dli;
    dli.Size = size;
    dli.Type = t;
    DebugInfo[0] = dli;
}

void log_(uint index, float4 f)
{
    Debug[XYZ(id().x, id().y, index, CalculationSize)] = f;
}

// ###################################### SHADER BASE END ######################################

#include "distance.hlsl"
#include "convert.hlsl"
#include "paint.hlsl"
#include "math.hlsl"
#include "rakel.hlsl"
#include "mapped_info.hlsl"

uint TextureResolution;

float3 CanvasPosition;
float2 CanvasSize;

RWStructuredBuffer<Rakel> RakelInfo;
uint2 RakelReservoirSize;

RWStructuredBuffer<MappedInfo> RakelMappedInfo;


// returns:
// - x: exact projection of canvas pixel.x to rakel reservoir index space
// - y: exact projection of canvas pixel.y to rakel reservoir index space
// - z: distance from rakel: -inf .. +inf
MappedInfo rakel_mapped(int2 pos_pixel)
{
    Rakel rakel = RakelInfo[0];

    // translate pixel to world space
    float3 pos_world_space = pixel_to_world_space(pos_pixel, TextureResolution, CanvasPosition, CanvasSize);

    // translate back so pixel is anchor aligned
    float3 back_translation_position = rakel.anchor - float3(rakel.position.x, rakel.position.y, 0);
    float3 pos_back_translated_position = pos_world_space + back_translation_position;

    // rotate back around anchor
    float3 pos_back_rotated = rotate_by_z(pos_back_translated_position, - rakel.rotation, rakel.anchor);

    // calculate results
    float rakel_tilted_x_max = rakel.lr_tilted.x;
    float rakel_tilted_x_min = rakel.ll_tilted.x;
    float rakel_tilted_dx = rakel_tilted_x_max - rakel_tilted_x_min;
    float part_x = (pos_back_rotated.x - rakel_tilted_x_min) / rakel_tilted_dx;
    float part_y = pos_back_rotated.y / rakel.length; // currently easy, because there is no length tilt

    float dist = distance_from_rakel(pos_back_rotated, rakel.ll_tilted, rakel.lr_tilted, float3(rakel.anchor.x, rakel.anchor.y, rakel.position.z));
    
    // NOTE: this calculation does not work for a curved rakel
    // part_x 0 means actually left from the pixel center, because the part_ info is about world space
    // reservoir_pixel is -0.5 for part_k == 0 and RakelReservoirSize.k - 1 + 0.5 for part_k == 1
    float2 reservoir_pixel = float2(part_x * RakelReservoirSize.x - 0.5,
                                    part_y * RakelReservoirSize.y - 0.5);

    MappedInfo mapped_info;
    mapped_info.reservoir_pixel = reservoir_pixel;
    mapped_info.distance = dist;
    return mapped_info;
}

#pragma kernel main

[numthreads(32,1,1)]
void main (uint3 id_ : SV_DispatchThreadID)
{
    id__ = id_;
    if (is_relevant_thread(id(), CalculationSize))
    {
        // calculate pixel position on canvas
        // was uint2 before, but negative values are possible due to padding and no prevention of that because it should not cause any more problems
        int2 canvas_pixel = id() + CalculationPosition;

        RakelMappedInfo[XY(id().x, id().y, CalculationSize.x)] = rakel_mapped(canvas_pixel);
    }
}