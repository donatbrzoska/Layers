// ######################################## SHADER BASE ########################################

#include "basic_util.hlsl"
#include "indexing.hlsl"
#include "logging.hlsl"

uint3 id__;
uint2 SubgridGroupSize;
uint2 SubgridCurrentThreadID;

uint2 id()
{
    uint2 subgrid_id = uint2(id__.x, id__.y);
    return subgrid_id * SubgridGroupSize + SubgridCurrentThreadID;
}

int2 CalculationPosition;
uint2 CalculationSize;

RWStructuredBuffer<float4> Debug;
RWStructuredBuffer<DebugListInfo> DebugInfo;

void set_debug_list_info(uint size, uint t)
{
    DebugListInfo dli;
    dli.Size = size;
    dli.Type = t;
    DebugInfo[0] = dli;
}

void log_(uint index, float4 f)
{
    Debug[XYZ(id().x, id().y, index, CalculationSize)] = f;
}

// ###################################### SHADER BASE END ######################################

#include "distance.hlsl"
#include "convert.hlsl"
#include "paint.hlsl"
#include "math.hlsl"
#include "sutherland_hodgman.hlsl"

uint2 TextureSize;
uint TextureResolution;
float3 CanvasPosition;
float2 CanvasSize;

float3 RakelAnchor;
float3 RakelPosition;
float RakelLength;
float RakelWidth;

float RakelRotation;
float RakelTilt;
int ClipRadiusX;

float3 RakelULTilted;
float3 RakelURTilted;
float3 RakelLLTilted;
float3 RakelLRTilted;

// Emitting
float EmitVolumeApplicationReservoir;
float EmitVolumePickupReservoir;

uint2 RakelReservoirSize;
// uint2 RakelLowerLeftRounded;
RWStructuredBuffer<Paint> RakelApplicationReservoir;
RWStructuredBuffer<Paint> RakelPickupReservoir;

RWStructuredBuffer<Paint> RakelEmittedPaint;


// returns:
// - x: part of dx of rakel, 0-err..1+err would mean pixel is under rakel
// - y: part of dy of rakel, 0-err..1+err would mean pixel is under rakel
// - z: distance from rakel: -inf .. +inf
float3 rakel_mapped(int2 pos_pixel)
{
    // translate pixel to world space
    float3 pos_world_space = pixel_to_world_space(pos_pixel, TextureResolution, CanvasPosition, CanvasSize);

    // translate back so pixel is anchor aligned
    float3 back_translation_position = RakelAnchor - float3(RakelPosition.x, RakelPosition.y, 0);
    float3 pos_back_translated_position = pos_world_space + back_translation_position;

    // rotate back around anchor
    float3 pos_back_rotated = rotate_by_z(pos_back_translated_position, - RakelRotation, RakelAnchor);

    // calculate results
    float rakel_tilted_x_max = RakelLRTilted.x;
    float rakel_tilted_x_min = RakelLLTilted.x;
    float rakel_tilted_dx = rakel_tilted_x_max - rakel_tilted_x_min;
    float part_x = (pos_back_rotated.x - rakel_tilted_x_min) / rakel_tilted_dx;
    float part_y = pos_back_rotated.y / RakelLength; // currently easy, because there is no length tilt

    float3 rakel_normal = cross(RakelLLTilted - RakelLRTilted, RakelURTilted - RakelLRTilted);
    float dist = distance_point_plane(pos_back_rotated, RakelPosition, rakel_normal);

    return float3(part_x, part_y, dist);
}

bool pixel_in_reservoir_range(int2 pixel)
{
    return pixel.x >= 0
        && pixel.x < (int)RakelReservoirSize.x
        && pixel.y >= 0
        && pixel.y < (int)RakelReservoirSize.y;
}

// radius of 1 does an emit on a 3x3 area from emit source grid, based on the rounded reservoir_pixel
void emit(float2 reservoir_pixel, int2 radius)
{
    int2 reservoir_pixel_nearest = round(reservoir_pixel);

    // TODO ratio of application and pickup reservoir
    float VOLUME_TO_EMIT_TARGET_APP = EmitVolumeApplicationReservoir * PAINT_UNIT();
    float VOLUME_TO_EMIT_TARGET_PU = EmitVolumePickupReservoir * PAINT_UNIT();

    // Array size should really be [1+2*radius.y][1+2*radius.x] but we can't make dynamic arrays
    // in HLSL. So we do 9x9, which is enough for 79 degree tilt and more is not useful for emitting anyways.
    // Also, with 11x11 we would get the following warning:
    // Shader warning in 'EmitFromRakel': Program 'main', warning X4714: sum of temp registers and indexable temp registers times 32 threads exceeds the recommended total 16384.  Performance may be reduced at kernel main (on metal)
    float4 color_to_emit_app[9][9];
    float4 color_to_emit_pu[9][9];
    float volume_to_emit_app[9][9];
    float volume_to_emit_pu[9][9];
    float4 result_color_app = float4(0,0,0,0);
    float4 result_color_pu = float4(0,0,0,0);
    float result_volume_app = 0;
    float result_volume_pu = 0;
    int y, x; // declare loop variables here so the compiler won't complain about double declaration of y
    for (y=-radius.y; y<=radius.y; y++) {
        for (x=-radius.x; x<=radius.x; x++) {
            // initialize arrays
            uint i = y + radius.y;
            uint j = x + radius.x;
            volume_to_emit_app[i][j] = 0;
            volume_to_emit_pu[i][j] = 0;
            color_to_emit_app[i][j] = float4(0,0,0,0);
            color_to_emit_pu[i][j] = float4(0,0,0,0);

            // calculate part
            int2 coord = reservoir_pixel_nearest + int2(x, y);
            if (pixel_in_reservoir_range(coord)) { // Prevent out of bounds access to reservoir. Also, if it's not in range, this overlap part is not (and must not be!) used anyways.
                float2 rakel_anchor_index_space = rakel_anchor_to_index_space(RakelAnchor, TextureResolution);
                float2 rect_reservoir_pixel = rotate_by_y_2D(reservoir_pixel, RakelTilt, rakel_anchor_index_space);
                float2 rect_coord = rotate_by_y_2D(coord, RakelTilt, rakel_anchor_index_space);
                Rectangle fragment_rectangle = create_rectangle(rect_reservoir_pixel, -RakelRotation, 0);
                Rectangle reservoir_rectangle = create_rectangle(rect_coord, 0, RakelTilt);
                float overlap = calculate_exact_overlap(fragment_rectangle, reservoir_rectangle);

                if (overlap > 0) {
                    // get paint
                    uint2 coord_ = uint2(coord.x, coord.y);
                    Paint available_app = RakelApplicationReservoir[XYZ(coord_.x, coord_.y, 1, RakelReservoirSize)];
                    Paint available_pu = RakelPickupReservoir[XYZ(coord_.x, coord_.y, 1, RakelReservoirSize)];

                    // calculate volume
                    float target_volume_app = overlap * VOLUME_TO_EMIT_TARGET_APP;
                    float target_volume_pu = overlap * VOLUME_TO_EMIT_TARGET_PU;
                    float really_available_volume_app = overlap * available_app.volume;
                    float really_available_volume_pu = overlap * available_pu.volume;
                    volume_to_emit_app[i][j] = min(target_volume_app, really_available_volume_app);
                    volume_to_emit_pu[i][j] = min(target_volume_pu, really_available_volume_pu);
                    result_volume_app += volume_to_emit_app[i][j];
                    result_volume_pu += volume_to_emit_pu[i][j];

                    color_to_emit_app[i][j] = available_app.color;
                    color_to_emit_pu[i][j] = available_pu.color;
                }
            }
        }
    }

    // determine color based on emitted volumes
    // TODO use mix function
    for (y=-radius.y; y<=radius.y; y++) {
        for (x=-radius.x; x<=radius.x; x++) {
            int2 coord = reservoir_pixel_nearest + int2(x, y);
            if (pixel_in_reservoir_range(coord)) {
                uint i = y + radius.y;
                uint j = x + radius.x;
                float volume_part_app = volume_to_emit_app[i][j] / unzero(result_volume_app);
                float volume_part_pu = volume_to_emit_pu[i][j] / unzero(result_volume_pu);
                result_color_app += volume_part_app * color_to_emit_app[i][j];
                result_color_pu += volume_part_pu * color_to_emit_pu[i][j];
            }
        }
    }

    Paint result_paint_app;
    Paint result_paint_pu;
    result_paint_app.color = result_color_app;
    result_paint_pu.color = result_color_pu;
    result_paint_app.volume = result_volume_app;
    result_paint_pu.volume = result_volume_pu;

    Paint result_paint = mix(result_paint_app, result_paint_pu);

    // delete amount of taken volume from reservoir (z=0)
    float deleted = 0;
    for (y=-radius.y; y<=radius.y; y++) {
        for (x=-radius.x; x<=radius.x; x++) {
            int2 coord = reservoir_pixel_nearest + int2(x, y);
            if (pixel_in_reservoir_range(coord)) {
                uint i = y + radius.y;
                uint j = x + radius.x;
                float to_be_deleted_app = volume_to_emit_app[i][j];
                float to_be_deleted_pu = volume_to_emit_pu[i][j];

                uint2 coord_ = uint2(coord.x, coord.y);
                RakelApplicationReservoir[XYZ(coord_.x, coord_.y, 0, RakelReservoirSize)].volume -= to_be_deleted_app;
                deleted += to_be_deleted_app;
                RakelPickupReservoir[XYZ(coord_.x, coord_.y, 0, RakelReservoirSize)].volume -= to_be_deleted_pu;
            }
        }
    }

    RakelEmittedPaint[XY(id().x, id().y, CalculationSize.x)] = result_paint;
    // log_float(deleted);
}

#pragma kernel main

[numthreads(32,1,1)]
void main (uint3 id_ : SV_DispatchThreadID)
{
    id__ = id_;
    if (is_relevant_thread(id(), CalculationSize))
    {
        // calculate pixel position on canvas
        // was uint2 before, but negative values are possible due to padding and no prevention of that because it should not cause any more problems
        int2 canvas_pixel = id() + CalculationPosition;
        float3 rakel_mapped_info = rakel_mapped(canvas_pixel);

        // NOTE: this calculation does not work for a curved rakel
        // rakel_mapped_info.x 0 means actually left from the pixel center, because the part_ info is about world space
        // reservoir_pixel is -0.5 for part_k == 0 and RakelReservoirSize.k - 1 + 0.5 for part_k == 1
        float2 reservoir_pixel = float2(rakel_mapped_info.x * RakelReservoirSize.x - 0.5,
                                        rakel_mapped_info.y * RakelReservoirSize.y - 0.5);
        
        emit(reservoir_pixel, uint2(ClipRadiusX, 1));
    }
}