// ######################################## SHADER BASE ########################################

#include "basic_util.hlsl"
#include "indexing.hlsl"
#include "logging.hlsl"

uint3 id__;
uint2 SubgridGroupSize;
uint2 SubgridCurrentThreadID;

uint2 id()
{
    uint2 subgrid_id = uint2(id__.x, id__.y);
    return subgrid_id * SubgridGroupSize + SubgridCurrentThreadID;
}

int2 CalculationPosition;
uint2 CalculationSize;

RWStructuredBuffer<float4> Debug;
RWStructuredBuffer<DebugListInfo> DebugInfo;

void set_debug_list_info(uint size, uint t)
{
    DebugListInfo dli;
    dli.Size = size;
    dli.Type = t;
    DebugInfo[0] = dli;
}

void log_(uint index, float4 f)
{
    Debug[XYZ(id().x, id().y, index, CalculationSize)] = f;
}

// ###################################### SHADER BASE END ######################################

#include "paint.hlsl"

RWStructuredBuffer<Paint> CanvasReservoir;

RWStructuredBuffer<float4> CanvasTexture;
RWStructuredBuffer<float4> CanvasNormalMap;

RWTexture2D<float4> Texture;
RWTexture2D<float4> NormalMap;

float NormalScale;
uint2 TextureSize;


bool pixel_in_canvas_range(int2 pixel)
{
    return pixel.x >= 0
        && pixel.x < (int)TextureSize.x
        && pixel.y >= 0
        && pixel.y < (int)TextureSize.y;
}

void update_normal(int2 canvas_pixel)
{
    // calculate normal
    // ... ... deal with oob access
    uint left = clamp(canvas_pixel.x-1, 0, TextureSize.x-1);
    uint right = clamp(canvas_pixel.x+1, 0, TextureSize.x-1);
    uint up = clamp(canvas_pixel.y+1, 0, TextureSize.y-1);
    uint bot = clamp(canvas_pixel.y-1, 0, TextureSize.y-1);
    
    // ... ... get volumes
    float vol_ul = CanvasReservoir[XY(left,           up,             TextureSize.x)].volume;
    float vol_u =  CanvasReservoir[XY(canvas_pixel.x, up,             TextureSize.x)].volume;
    float vol_ur = CanvasReservoir[XY(right,          up,             TextureSize.x)].volume;
    float vol_l =  CanvasReservoir[XY(left,           canvas_pixel.y, TextureSize.x)].volume;
    float vol_m =  CanvasReservoir[XY(canvas_pixel.x, canvas_pixel.y, TextureSize.x)].volume;
    float vol_r =  CanvasReservoir[XY(right,          canvas_pixel.y, TextureSize.x)].volume;
    float vol_ll = CanvasReservoir[XY(left,           bot,            TextureSize.x)].volume;
    float vol_b =  CanvasReservoir[XY(canvas_pixel.x, bot,            TextureSize.x)].volume;
    float vol_lr = CanvasReservoir[XY(right,          bot,            TextureSize.x)].volume;

    // ... ... sobel calculation
    float normal_x = -1 * vol_ul            + 1 * vol_ur
                + -2 * vol_l             + 2 * vol_r
                + -1 * vol_ll            + 1 * vol_lr;

    float normal_y = -1 * vol_ul + -2 * vol_u + -1 * vol_ur

                +  1 * vol_ll +  2 * vol_b +  1 * vol_lr;

    float normal_z = 1;

    // ... ... scaling and normal assembly
    float scale = NormalScale;
    
    float4 normal = float4(scale * (float)(-normal_x), scale * (float)(normal_y), normal_z, 1);
    float4 normalized = normalize(normal);
    float4 halfed = (normalized + float4(1, 1, 1, 1)) / 2;
    float4 paint_normal = float4(halfed.x, halfed.y, halfed.z, 1);
    float4 result = paint_normal;

    // let canvas normals shine through, when there is very little paint on canvas
    float VERY_LITTLE_PAINT = PAINT_UNIT();
    float volume_on_canvas = (vol_ul + vol_u + vol_ur + vol_l + vol_m + vol_r + vol_ll + vol_b + vol_lr) / 9;
    if (volume_on_canvas < VERY_LITTLE_PAINT)
    {
        float volume_normal_part = volume_on_canvas / VERY_LITTLE_PAINT;
        float canvas_normal_part = 1 - volume_normal_part;

        float4 canvas_normal = CanvasNormalMap[XY(canvas_pixel.x, canvas_pixel.y, TextureSize.x)];
        result = volume_normal_part * volume_on_canvas + canvas_normal_part * canvas_normal;
    }

    NormalMap[canvas_pixel] = result;
}

void update_color(int2 canvas_pixel)
{
    // get paint from canvas
    Paint p = CanvasReservoir[XY(canvas_pixel.x, canvas_pixel.y, TextureSize.x)];
    // blend little paint with canvas color
    // we can't use alpha values, because there is nothing behind the paint - the paint is the texture
    if (p.volume < PAINT_UNIT()) {
        p = alpha_blend(p, CanvasTexture[XY(canvas_pixel.x, canvas_pixel.y, TextureSize.x)]);
    }

    // set color
    Texture[canvas_pixel] = p.color;
}

#pragma kernel main

[numthreads(32,1,1)]
void main (uint3 id_ : SV_DispatchThreadID)
{
    id__ = id_;
    if (is_relevant_thread(id(), CalculationSize))
    {
        // calculate pixel position on canvas
        int2 canvas_pixel = id() + CalculationPosition;
        if (pixel_in_canvas_range(canvas_pixel))
        {
            update_normal(canvas_pixel);
            update_color(canvas_pixel);
        }
    }
}