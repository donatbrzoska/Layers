#include "shader_base.hlsl"

#include "paint.hlsl"

RWStructuredBuffer<Paint> CanvasReservoir;
uint ColorSpace;

RWTexture2D<float4> NormalMap;
float NormalScale;
RWTexture2D<float4> Texture;
uint2 TextureSize;


float4 CANVAS_COLOR(uint color_space)
{
    float4 rgb_color = float4(1,1,1,1);
    return (color_space == 0) ? rgb_color : rgb_to_ryb(rgb_color);
}

void update_normal(int2 canvas_pixel)
{
    // calculate normal
    // ... ... deal with oob access
    uint left = clamp(canvas_pixel.x-1, 0, TextureSize.x-1);
    uint right = clamp(canvas_pixel.x+1, 0, TextureSize.x-1);
    uint up = clamp(canvas_pixel.y+1, 0, TextureSize.y-1);
    uint bot = clamp(canvas_pixel.y-1, 0, TextureSize.y-1);
    
    // ... ... get volumes
    float vol_ul = CanvasReservoir[XY(left,           up,             TextureSize.x)].volume;
    float vol_u =  CanvasReservoir[XY(canvas_pixel.x, up,             TextureSize.x)].volume;
    float vol_ur = CanvasReservoir[XY(right,          up,             TextureSize.x)].volume;
    float vol_l =  CanvasReservoir[XY(left,           canvas_pixel.y, TextureSize.x)].volume;
    float vol_m =  CanvasReservoir[XY(canvas_pixel.x, canvas_pixel.y, TextureSize.x)].volume;
    float vol_r =  CanvasReservoir[XY(right,          canvas_pixel.y, TextureSize.x)].volume;
    float vol_ll = CanvasReservoir[XY(left,           bot,            TextureSize.x)].volume;
    float vol_b =  CanvasReservoir[XY(canvas_pixel.x, bot,            TextureSize.x)].volume;
    float vol_lr = CanvasReservoir[XY(right,          bot,            TextureSize.x)].volume;

    // ... ... sobel calculation
    float normal_x = -1 * vol_ul            + 1 * vol_ur
                + -2 * vol_l             + 2 * vol_r
                + -1 * vol_ll            + 1 * vol_lr;

    float normal_y = -1 * vol_ul + -2 * vol_u + -1 * vol_ur

                +  1 * vol_ll +  2 * vol_b +  1 * vol_lr;

    float normal_z = 1;

    // ... ... scaling and normal assembly
    float scale = NormalScale;
    
    float4 normal = float4(scale * (float)(-normal_x), scale * (float)(normal_y), normal_z, 1);
    float4 normalized = normalize(normal);
    float4 halfed = (normalized + float4(1, 1, 1, 1)) / 2;
    halfed.w = 1;

    NormalMap[canvas_pixel] = halfed;
}

void update_color(int2 canvas_pixel)
{
    // get paint from canvas
    Paint p = CanvasReservoir[XY(canvas_pixel.x, canvas_pixel.y, TextureSize.x)];

    // blend little paint with canvas color
    // we can't use alpha values, because there is nothing behind the paint - the paint is the texture
    if (p.volume < PAINT_UNIT()) {
        float4 canvas_color = CANVAS_COLOR(ColorSpace);
        p = alpha_blend(p, canvas_color);
    }

    // float3 result = ryb_to_rgb(float3(1, 1, 0));
    // p.color = float4(result.x, result.y, result.z, 1);

    // set color
    Texture[canvas_pixel] = (ColorSpace == 1) ? ryb_to_rgb(p.color) : p.color;
}

#pragma kernel main

[numthreads(32,1,1)]
void main (uint3 id_ : SV_DispatchThreadID)
{
    id__ = id_;
    if (is_relevant_thread(id(), CalculationSize))
    {
        // calculate pixel position on canvas
        int2 canvas_pixel = id() + CalculationPosition;
        if (pixel_in_array_range(canvas_pixel, TextureSize))
        {
            update_normal(canvas_pixel);
            update_color(canvas_pixel);
        }
    }
}