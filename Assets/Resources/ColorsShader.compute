#pragma kernel main

// RWStructuredBuffer<float3> Debug;

uint2 CalculationSize;

int2 CalculationPosition;

struct Paint {
    float4 color;
    int volume;
};
RWStructuredBuffer<Paint> CanvasReservoir;

RWTexture2D<float4> CanvasTexture;
uint2 TextureSize;


// RWStructuredBuffer<int> Finished;


bool is_relevant_thread(uint3 id)
{
    return all(id.xy < CalculationSize);
}

bool pixel_in_canvas_range(int2 pixel)
{
    return pixel.x >= 0
        && pixel.x < (int)TextureSize.x
        && pixel.y >= 0
        && pixel.y < (int)TextureSize.y;
}

uint XY(uint x, uint y, uint width)
{
    return y * width + x;
}

[numthreads(1,8,1)]
void main (uint3 id : SV_DispatchThreadID)
{
    // Filter #1
    if (is_relevant_thread(id))
    {
        // calculate pixel position on canvas
        int2 canvas_pixel = id.xy + CalculationPosition;
        if (pixel_in_canvas_range(canvas_pixel))
        {

            // get paint from canvas
            Paint p = CanvasReservoir[XY(canvas_pixel.x, canvas_pixel.y, TextureSize.x)];

            // set color
            if (p.volume > 0)
            {
                CanvasTexture[canvas_pixel] = p.color;
            }
        }
    }
    // if (id.x == 0 && id.y == 0)
    // {
    //     Finished[0] = 1;
    // }
}