// ######################################## SHADER BASE ########################################

#pragma kernel main

#include "basic_util.hlsl"
#include "index_util.hlsl"
#include "log_util.hlsl"

uint3 id;

uint2 CalculationSize;

RWStructuredBuffer<float4> Debug;
RWStructuredBuffer<int> DebugType;
// RWStructuredBuffer<int> Finished;

void set_debug_type(int t)
{
    DebugType[0] = t;
}

void log_(float4 f)
{
    Debug[XY(id.x, id.y, CalculationSize.x)] = f;
}

// ###################################### SHADER BASE END ######################################

#include "paint.hlsl"

int2 CalculationPosition;

RWStructuredBuffer<Paint> CanvasReservoir;

RWTexture2D<float4> CanvasTexture;
uint2 TextureSize;


bool pixel_in_canvas_range(int2 pixel)
{
    return pixel.x >= 0
        && pixel.x < (int)TextureSize.x
        && pixel.y >= 0
        && pixel.y < (int)TextureSize.y;
}

[numthreads(1,8,1)]
void main (uint3 id_ : SV_DispatchThreadID)
{
    id = id_;
    if (is_relevant_thread(id, CalculationSize))
    {
        // calculate pixel position on canvas
        int2 canvas_pixel = id.xy + CalculationPosition;
        if (pixel_in_canvas_range(canvas_pixel))
        {
            // get paint from canvas
            Paint p = CanvasReservoir[XY(canvas_pixel.x, canvas_pixel.y, TextureSize.x)];

            // blend little paint with canvas color
            // we can't use alpha values, because there is nothing behind the paint - the paint is the texture
            if (p.volume < 1000) {
                p = simulate_alpha(p);
            }

            // render empty paint as white
            if (is_empty(p)) {
                p.color = EMPTY_PAINT_COLOR();
            }

            // set color
            CanvasTexture[canvas_pixel] = p.color;
        }
    }
    // if (id.x == 0 && id.y == 0)
    // {
    //     Finished[0] = 1;
    // }
}