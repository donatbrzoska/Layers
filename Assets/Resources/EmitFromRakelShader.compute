// ######################################## SHADER BASE ########################################

#pragma kernel main

#include "basic_util.hlsl"
#include "index_util.hlsl"
#include "log_util.hlsl"

uint3 id;

// Filter #1
uint2 CalculationSize;

RWStructuredBuffer<float4> Debug;
RWStructuredBuffer<int> DebugType;

void set_debug_type(int t)
{
    DebugType[0] = t;
}

void log_(float4 f)
{
    Debug[XY(id.x, id.y, CalculationSize.x)] = f;
}

// ###################################### SHADER BASE END ######################################

#include "paint.hlsl"
#include "math_util.hlsl"
#include "bilinear_interpolation_util.hlsl"
#include "sutherland_hodgman.hlsl"

uint2 CalculationPosition;

uint2 TextureSize;
uint TextureResolution;
float3 CanvasPosition;
float2 CanvasSize;

float3 RakelAnchor;
float3 RakelPosition;
float RakelLength;
float RakelWidth;

float RakelRotation;

float3 RakelULTilted;
float3 RakelURTilted;
float3 RakelLLTilted;
float3 RakelLRTilted;

// Emitting
uint TransferMapMode;

uint2 RakelReservoirSize;
uint RakelReservoirResolution;
// uint2 RakelLowerLeftRounded;
RWStructuredBuffer<Paint> RakelApplicationReservoir;

RWStructuredBuffer<Paint> RakelEmittedPaint;


// RWStructuredBuffer<int> Finished;


float3 map_to_world_space(int2 pixel, uint texture_resolution, float3 canvas_position, float2 canvas_size)
{
    float pixel_size = 1/float(texture_resolution);
    float3 positive_canvas_aligned = float3(0.5*pixel_size + pixel.x*pixel_size,
                                            0.5*pixel_size + pixel.y*pixel_size,
                                            0);

    float3 canvas_lower_left = canvas_position - float3(canvas_size.x/2, canvas_size.y/2, 0);
    float3 canvas_aligned = positive_canvas_aligned + canvas_lower_left;

    return canvas_aligned;
}


// returns:
// - x: part of dx of rakel, 0-err..1+err would mean pixel is under rakel
// - y: part of dy of rakel, 0-err..1+err would mean pixel is under rakel
// - z: distance from rakel: -inf .. +inf
float3 rakel_mapped(int2 pos_pixel)
{
    // translate pixel to world space
    float3 pos_world_space = map_to_world_space(pos_pixel, TextureResolution, CanvasPosition, CanvasSize);

    // translate back so pixel is anchor aligned
    float3 back_translation_position = - (float3(RakelPosition.x, RakelPosition.y, 0) - RakelAnchor);
    float3 pos_back_translated_position = pos_world_space + back_translation_position;

    // rotate back around anchor
    float3 pos_back_rotated = rotate_by_z(pos_back_translated_position, - RakelRotation, RakelAnchor);

    // calculate results
    float rakel_tilted_x_max = RakelLRTilted.x;
    float rakel_tilted_x_min = RakelLLTilted.x;
    float rakel_tilted_dx = rakel_tilted_x_max - rakel_tilted_x_min;
    float part_x = (pos_back_rotated.x - rakel_tilted_x_min) / rakel_tilted_dx;
    float part_y = pos_back_rotated.y / RakelLength; // currently easy, because there is no length tilt

    float m = (RakelLRTilted.y - RakelLLTilted.y) / (RakelLRTilted.x - RakelLLTilted.x);
    float c = RakelPosition.y - m * RakelPosition.x;
    float dist = m * pos_back_rotated.x + c;

    return float3(part_x, part_y, dist);
}

bool pixel_in_reservoir_range(int2 pixel)
{
    return pixel.x >= 0
        && pixel.x < (int)RakelReservoirSize.x
        && pixel.y >= 0
        && pixel.y < (int)RakelReservoirSize.y;
}

// radius of 1 does an emit on a 3x3 area from emit source grid, based on the rounded reservoir_pixel
void emit(float2 reservoir_pixel, int2 radius)
{
    // Debug[XY(id.x, id.y, CalculationSize.x)] = reservoir_pixel;
    int2 reservoir_pixel_nearest = round(reservoir_pixel);

    // 1000 volume is one unit of paint, since it doesnt make sense to
    // calculate parts of smaller integers and we have to use integers because of InterlockedAdd
    int VOLUME_TO_EMIT_TARGET = 1000;

    // array size should really be [1+2*radius.y][1+2*radius.x] but we can't make dynamic arrays
    // in HLSL. 9x9 should be enough though, since with 45Â° tilt we will probably use 6x6 and
    // more tilt probably won't emit anyways
    float volume_to_emit[9][9];
    float part_sum = 0;
    float4 result_color = float4(0,0,0,0);
    float result_volume = 0;
    for (int y=-radius.y; y<=radius.y; y++) {
        for (int x=-radius.x; x<=radius.y; x++) {
            // initialize array
            uint i = y + radius.y;
            uint j = x + radius.x;
            volume_to_emit[i][j] = 0;

            // calculate part
            int2 coord = reservoir_pixel_nearest + int2(x, y);
            if (pixel_in_reservoir_range(coord)) { // Prevent out of bounds access to reservoir. Also, if it's not in range, this overlap part is not used anyways.
                float overlap = 0;
                if (TransferMapMode == 0) { // nearest neighbour
                    overlap = 1;
                } else if (TransferMapMode == 1) { // bilinear interpolation
                    overlap = calculate_unrotated_overlap(coord, 1, reservoir_pixel, 1);
                } else if (TransferMapMode == 2) { // polygon clipping
                    overlap = calculate_exact_overlap(coord, reservoir_pixel, -RakelRotation);
                }
                part_sum += overlap;

                if (overlap > 0) {
                    // get paint
                    uint2 coord_ = uint2(coord.x, coord.y);
                    Paint available = RakelApplicationReservoir[XYZ(coord_.x, coord_.y, 1, RakelReservoirSize)];

                    // calculate volume
                    int target_volume = overlap * VOLUME_TO_EMIT_TARGET;
                    int really_available_volume = overlap * available.volume;
                    volume_to_emit[i][j] = min(target_volume, really_available_volume);
                    result_volume += volume_to_emit[i][j];

                    // add up color
                    result_color += (overlap * available.color);
                }
            }
        }
    }

    // make sure to keep color brightness for border cases
    result_color /= part_sum; // TODO what if part_sum is 0
    Paint result_paint;
    result_paint.color = result_color;
    result_paint.volume = result_volume;

    if (result_paint.volume > 0)
    {
        // delete amount of taken volume from reservoir (z=0)
        int deleted = 0;
        for (int y=-radius.y; y<=radius.y; y++) {
            for (int x=-radius.x; x<=radius.x; x++) {
                int2 coord = reservoir_pixel_nearest + int2(x, y);
                if (pixel_in_reservoir_range(coord)) {
                    uint i = y + radius.y;
                    uint j = x + radius.x;
                    int to_be_deleted = volume_to_emit[i][j];

                    uint2 coord_ = uint2(coord.x, coord.y);
                    InterlockedAdd(RakelApplicationReservoir[XYZ(coord_.x, coord_.y, 0, RakelReservoirSize)].volume, -to_be_deleted);
                    deleted += to_be_deleted;
                }
            }
        }
        // Debug[XY(id.x, id.y, CalculationSize.x)] = float2(deleted, 0);

        RakelEmittedPaint[XY(id.x, id.y, CalculationSize.x)] = result_paint;
    }
}

void do_emit(float2 reservoir_pixel)
{
    if (TransferMapMode == 0) {
        emit(reservoir_pixel, 0);
    } else {
        emit(reservoir_pixel, 1);
    }
}

[numthreads(1,8,1)]
void main (uint3 id_ : SV_DispatchThreadID)
{
    id = id_;
    // Filter #1
    if (is_relevant_thread(id, CalculationSize))
    {
        // calculate pixel position on canvas
        // was uint2 before, but negative values are possible due to padding and no prevention of that because it should not cause any more problems
        int2 canvas_pixel = id.xy + CalculationPosition;
        // Filter #2
        float3 rakel_mapped_info = rakel_mapped(canvas_pixel);

        // NOTE: this calculation does not work for a curved rakel
        float reservoir_pixel_size = 1/float(RakelReservoirResolution);
            // rakel_mapped_info.x 0 means actually left from the pixel, because the part_ info is about world space
            // reservoir_pixel is -0.5 for part_k == 0 and RakelReservoirSize.k - 1 + 0.5 for part_k == 1
        float2 reservoir_pixel = float2(rakel_mapped_info.x * RakelReservoirSize.x - 0.5,
                                        rakel_mapped_info.y * RakelReservoirSize.y - 0.5);
        
        do_emit(reservoir_pixel);
        // log_float(2);
    }
    // if (id.x == 0 && id.y == 0)
    // {
    //     Finished[0] = 2;
    // }
}