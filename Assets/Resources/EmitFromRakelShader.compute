#pragma kernel main
// https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions
// https://learn.microsoft.com/en-us/windows/win32/direct3d11/direct3d-11-advanced-stages-cs-atomic-functions

// RWStructuredBuffer<float2> Debug;
uint3 id;

// Filter #1
uint2 CalculationSize;

// Filter #2
uint2 CalculationPosition;

uint2 TextureSize;
uint TextureResolution;
float3 CanvasPosition;
float2 CanvasSize;

float3 RakelAnchor;
float3 RakelPosition;
float RakelLength;
float RakelWidth;

float RakelRotation;

float3 RakelULTilted;
float3 RakelURTilted;
float3 RakelLLTilted;
float3 RakelLRTilted;

// Emitting
struct Paint {
    float4 color;
    int volume;
};
uint2 RakelReservoirSize;
uint RakelReservoirResolution;
// uint2 RakelLowerLeftRounded;
RWStructuredBuffer<Paint> RakelApplicationReservoir;

RWStructuredBuffer<Paint> RakelEmittedPaint;


// RWStructuredBuffer<int> Finished;


bool f2_eq(float2 a, float2 b){
    float err = 0.01;
    return abs(a.x - b.x) < err
        && abs(a.y - b.y) < err;
}

uint IJ(uint i, uint j)
{
    return i * 2 + j;
}

uint XY(uint x, uint y, uint width)
{
    return y * width + x;
}

uint XYZ(uint x, uint y, uint z, uint2 dimensions)
{
    return z * dimensions.y * dimensions.x + y * dimensions.x + x;
}

// // b is right from a
// float angle_between(float3 a, float3 b)
// {
//     return acos(dot(a,b)/(length(a)*length(b))); // TODO MAYBE THIS IS BUGGY BECAUSE OF RADS/DEGREES
// }

bool is_relevant_thread(uint3 id)
{
    return all(id.xy < CalculationSize);
}

float3 map_to_world_space(int2 pixel, uint texture_resolution, float3 canvas_position, float2 canvas_size)
{
    float pixel_size = 1/float(texture_resolution);
    float3 positive_canvas_aligned = float3(0.5*pixel_size + pixel.x*pixel_size,
                                            0.5*pixel_size + pixel.y*pixel_size,
                                            0);

    float3 canvas_lower_left = canvas_position - float3(canvas_size.x/2, canvas_size.y/2, 0);
    float3 canvas_aligned = positive_canvas_aligned + canvas_lower_left;

    return canvas_aligned;
}

// rotates clockwise
float3 rotate_by_z(float3 vec, float angle, float3 around)
{
    float3 vec_ = vec - around;

    float rad = radians(angle);
    float s = sin(rad);
    float c = cos(rad);
    float3x3 rotation = {
        c, -s, 0,
        s,  c, 0,
        0,  0, 1
    };
    
    float3 result = mul(vec_, rotation);
    return result + around;


    // float3 origin_aligned = vec - around;
    // float2 vec_ = float2(origin_aligned.x, origin_aligned.y);

    // float rad = radians(angle);
    // float s = sin(rad);
    // float c = cos(rad);
    // float2x2 rotation = {
    //     c, -s,
    //     s,  c,
    // };
    
    // float2 result = mul(vec_, rotation);
    // return float3(result.x, result.y, vec.z) + around;
}

// rotates clockwise
float2 rotate(float2 vec, float angle, float2 around)
{
    float2 vec_ = vec - around;

    float rad = radians(angle);
    float s = sin(rad);
    float c = cos(rad);
    float2x2 rotation = {
        c, -s,
        s,  c,
    };

    float2 result = mul(vec_, rotation);
    return result + around;
}

// returns:
// - x: part of dx of rakel, 0-err..1+err would mean pixel is under rakel
// - y: part of dy of rakel, 0-err..1+err would mean pixel is under rakel
// - z: distance from rakel: -inf .. +inf
float3 rakel_mapped(int2 pos_pixel)
{
    // translate pixel to world space
    float3 pos_world_space = map_to_world_space(pos_pixel, TextureResolution, CanvasPosition, CanvasSize);

    // translate back so pixel is anchor aligned
    float3 back_translation_position = - (float3(RakelPosition.x, RakelPosition.y, 0) - RakelAnchor);
    float3 pos_back_translated_position = pos_world_space + back_translation_position;

    // rotate back around anchor
    float3 pos_back_rotated = rotate_by_z(pos_back_translated_position, - RakelRotation, RakelAnchor);

    // calculate results
    float rakel_tilted_x_max = RakelLRTilted.x;
    float rakel_tilted_x_min = RakelLLTilted.x;
    float rakel_tilted_dx = rakel_tilted_x_max - rakel_tilted_x_min;
    float part_x = (pos_back_rotated.x - rakel_tilted_x_min) / rakel_tilted_dx;
    float part_y = pos_back_rotated.y / RakelLength; // currently easy, because there is no length tilt

    float m = (RakelLRTilted.y - RakelLLTilted.y) / (RakelLRTilted.x - RakelLLTilted.x);
    float c = RakelPosition.y - m * RakelPosition.x;
    float dist = m * pos_back_rotated.x + c;

    return float3(part_x, part_y, dist);
}

// float2 rotate_around_origin(int2 vec, float angle)
// {
//     float rad = radians(angle);
//     float s = sin(rad);
//     float c = cos(rad);
//     float2x2 mat = {
//         c, -s,
//         s,  c
//     };
//     return mul(vec, mat);
// }

bool pixel_in_reservoir_range(int2 pixel)
{
    return pixel.x >= 0
        && pixel.x < (int)RakelReservoirSize.x
        && pixel.y >= 0
        && pixel.y < (int)RakelReservoirSize.y;
}

bool vertex_inside(float2 vertex, float2 edge_v1, float2 edge_v2) {
    return (edge_v1.x - vertex.x) * (edge_v2.y - vertex.y) >= (edge_v1.y - vertex.y) * (edge_v2.x - vertex.x);
}

float2 compute_intersection(float2 a, float2 b, float2 p, float2 q) {
    if (a.y == b.y && b.y == p.y && p.y == q.y) { // lines identical with same y
        if (a.x < p.x) {
            return float2(min(p.x, q.x), a.y);
        } else {
            return float2(max(p.x, q.x), a.y);
        }
    } else if (a.x == b.x && b.x == p.x && p.x == q.x) { // lines identical with same x
        if (a.y < p.y) {
            return float2(a.x, min(p.y, q.y));
        } else {
            return float2(a.x, max(p.y, q.y));
        }
    } else {
        float m1 = (b.y - a.y) / (b.x - a.x);
        float k1 = a.y - m1 * a.x;

        float m2 = (q.y - p.y) / (q.x - p.x);
        float k2 = p.y - m2 * p.x;

        float x = (k2 - k1) / (m1 - m2);
        float y = m1 * x + k1;

        return float2(x, y);
    }
}

// inspired by Java implementation from https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping
float calculate_overlap_(int2 adjacent_reservoir_pixel, float2 reservoir_pixel)
{
    // 1. calculate clip and subject polygon -> adjacent_reservoir_pixel is clipping reservoir_pixel (back translated and rotated from canvas pixel)
    // vertices are stored in counter clockwise order
    float2 clip_poly[8];
    uint clip_len = 0;
    float2 subj_poly[8];
    uint subj_len = 0;

    float2 ll = float2(-0.5, -0.5);
    float2 ul = float2(-0.5,  0.5);
    float2 ur = float2( 0.5,  0.5);
    float2 lr = float2( 0.5, -0.5);

    float2 adjacent_reservoir_pixel_ = float2(adjacent_reservoir_pixel.x, adjacent_reservoir_pixel.y);
    clip_poly[0] = adjacent_reservoir_pixel_ + ll;
    clip_poly[1] = adjacent_reservoir_pixel_ + lr;
    clip_poly[2] = adjacent_reservoir_pixel_ + ur;
    clip_poly[3] = adjacent_reservoir_pixel_ + ul;
    clip_len = 4;

    // TODO this doesn't work for a curved or tilted rakel
    subj_poly[0] = reservoir_pixel + rotate(ll, RakelRotation, float2(0,0));
    subj_poly[1] = reservoir_pixel + rotate(lr, RakelRotation, float2(0,0));
    subj_poly[2] = reservoir_pixel + rotate(ur, RakelRotation, float2(0,0));
    subj_poly[3] = reservoir_pixel + rotate(ul, RakelRotation, float2(0,0));
    subj_poly[4] = float2(0,0);
    subj_poly[5] = float2(0,0);
    subj_poly[6] = float2(0,0);
    subj_poly[7] = float2(0,0);
    subj_len = 4;

    // 2. calculate intersection polygon
    float2 input_list[8];
    uint input_len;
    float2 output_list[] = subj_poly; // put subject polygon to output_list as this should be the input of the next (first) iteration
    uint output_len = subj_len;
    for (uint i=0; i<clip_len; i++) {
        input_list = output_list; // input is always output of last iteration = current state of clipped subject
        input_len = output_len;

        output_len = 0; // reset output_list

        float2 clip_a = clip_poly[i];
        float2 clip_b = clip_poly[(i == clip_len-1) ? 0 : (i+1)]; // wrap array around in last iteration
        for (uint j=0; j<input_len; j++) {
            float2 subj_a = input_list[j];
            float2 subj_b = input_list[(j == input_len-1) ? 0 : (j+1)]; // wrap array around in last iteration

            float2 intersection = compute_intersection(clip_a, clip_b, subj_a, subj_b);
            // challenge: vertices must get inserted in order
            if (vertex_inside(subj_b, clip_a, clip_b)) {
                if (!vertex_inside(subj_a, clip_a, clip_b)) {
                    output_list[output_len] = intersection;
                    output_len++;
                }
                output_list[output_len] = subj_b;
                output_len++;
            } else if (vertex_inside(subj_a, clip_a, clip_b)) {
                output_list[output_len] = intersection;
                output_len++;
            }
        }
    }

    // 3. calculate area of intersection polygon == overlap 0..1
    float area = 0;
    for (uint k=0; k<output_len; k++) {
        float2 v_i = output_list[k];
        float2 v_i_1 = output_list[(k == output_len-1) ? 0 : (k+1)]; // wrap array around in last iteration

        area += v_i.x * v_i_1.y - v_i_1.x * v_i.y;
    }
    area *= 0.5;
    return area;
}

void do_interpolated_emit(float2 reservoir_pixel)
{
    int2 reservoir_pixel_nearest = round(reservoir_pixel);

    // 1000 volume is one unit of paint, since it doesnt make sense to
    // calculate parts of smaller integers and we have to use integers because of InterlockedAdd
    int VOLUME_TO_EMIT_TARGET = 1000;
    float volume_to_emit[3][3];
    float part_sum = 0;
    float4 result_color = float4(0,0,0,0);
    float result_volume = 0;
    for (int y=-1; y<2; y++) {
        for (int x=-1; x<2; x++) {
            // initialize array
            volume_to_emit[y+1][x+1] = 0;

            // calculate part
            int2 coord = reservoir_pixel_nearest + int2(x, y);
            if (pixel_in_reservoir_range(coord)) { // Prevent out of bounds access to reservoir. Also, if it's not in range, this overlap part is not used anyways.
                float overlap = calculate_overlap_(coord, reservoir_pixel);
                part_sum += overlap;

                if (overlap > 0) {
                    // get paint
                    uint2 coord_ = uint2(coord.x, coord.y);
                    Paint available = RakelApplicationReservoir[XYZ(coord_.x, coord_.y, 1, RakelReservoirSize)];

                    // calculate volume
                    int target_volume = overlap * VOLUME_TO_EMIT_TARGET;
                    int really_available_volume = overlap * available.volume;
                    volume_to_emit[y+1][x+1] = min(target_volume, really_available_volume);
                    result_volume += volume_to_emit[y+1][x+1];

                    // add up color
                    result_color += (overlap * available.color);
                }
            }
        }
    }

    // make sure to keep color brightness for border cases
    result_color /= part_sum;
    Paint result_paint;
    result_paint.color = result_color;
    result_paint.volume = result_volume;

    if (result_paint.volume > 0)
    {
        // delete amount of taken volume from reservoir (z=0)
        int deleted = 0;
        for (int y=-1; y<2; y++) {
            for (int x=-1; x<2; x++) {
                int2 coord = reservoir_pixel_nearest + int2(x, y);
                if (pixel_in_reservoir_range(coord)) {
                    uint2 coord_ = uint2(coord.x, coord.y);
                    int to_be_deleted = volume_to_emit[y+1][x+1];
                    InterlockedAdd(RakelApplicationReservoir[XYZ(coord_.x, coord_.y, 0, RakelReservoirSize)].volume, -to_be_deleted);
                    deleted += to_be_deleted;
                }
            }
        }
        // Debug[XY(id.x, id.y, CalculationSize.x)] = float2(deleted, 0);

        RakelEmittedPaint[XY(id.x, id.y, CalculationSize.x)] = result_paint;
    }
}

[numthreads(1,8,1)]
void main (uint3 id_ : SV_DispatchThreadID)
{
    id = id_;
    // Filter #1
    if (is_relevant_thread(id))
    {
        // calculate pixel position on canvas
        // was uint2 before, but negative values are possible due to padding and no prevention of that because it should not cause any more problems
        int2 canvas_pixel = id.xy + CalculationPosition;
        // Filter #2
        float3 rakel_mapped_info = rakel_mapped(canvas_pixel);

        // NOTE: this calculation does not work for a curved rakel
        float reservoir_pixel_size = 1/float(RakelReservoirResolution);
            // rakel_mapped_info.x 0 means actually left from the pixel, because the part_ info is about world space
            // reservoir_pixel is -0.5 for part_k == 0 and RakelReservoirSize.k - 1 + 0.5 for part_k == 1
        float2 reservoir_pixel = float2(rakel_mapped_info.x * RakelReservoirSize.x - 0.5,
                                        rakel_mapped_info.y * RakelReservoirSize.y - 0.5);
        
        do_interpolated_emit(reservoir_pixel);
    }
    // if (id.x == 0 && id.y == 0)
    // {
    //     Finished[0] = 2;
    // }
}