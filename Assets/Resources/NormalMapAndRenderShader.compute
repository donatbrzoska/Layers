#pragma kernel main

// RWStructuredBuffer<float3> Debug;

// Filter #1
uint2 CalculationSize;

// Really emitting
uint2 CalculationPosition;

struct Paint {
    float4 color;
    int volume;
};
RWStructuredBuffer<Paint> Canvas;
uint2 CanvasSize; // == TextureWidth

RWTexture2D<float4> Texture;
RWTexture2D<float4> NormalMap;


// RWStructuredBuffer<int> Finished;


bool is_relevant_thread(uint3 id)
{
    return all(id.xy < CalculationSize);
}

uint XY(uint x, uint y, uint width)
{
    return y * width + x;
}

[numthreads(1,8,1)]
void main (uint3 id : SV_DispatchThreadID)
{
    // Filter #1
    if (is_relevant_thread(id))
    {
        // calculate pixel position on canvas
        uint2 canvas_pixel = id.xy + CalculationPosition;

        // get paint from canvas
        Paint p = Canvas[XY(canvas_pixel.x, canvas_pixel.y, CanvasSize.x)];

        // render
        // ... set color
        Texture[canvas_pixel] = p.color;

        // ... calculate normal
        // ... ... deal with oob access
        uint left = clamp(canvas_pixel.x-1, 0, CanvasSize.x-1);
        uint right = clamp(canvas_pixel.x+1, 0, CanvasSize.x-1);
        uint up = clamp(canvas_pixel.y+1, 0, CanvasSize.y-1);
        uint bot = clamp(canvas_pixel.y-1, 0, CanvasSize.y-1);
        
        // ... ... get volumes
        uint vol_ul = Canvas[XY(left,           up,             CanvasSize.x)].volume;
        uint vol_u =  Canvas[XY(canvas_pixel.x, up,             CanvasSize.x)].volume;
        uint vol_ur = Canvas[XY(right,          up,             CanvasSize.x)].volume;
        uint vol_l =  Canvas[XY(left,           canvas_pixel.y, CanvasSize.x)].volume;
        // uint vol_m =  Canvas[XY(canvas_pixel.x, canvas_pixel.y, CanvasSize.x)].volume;
        uint vol_r =  Canvas[XY(right,          canvas_pixel.y, CanvasSize.x)].volume;
        uint vol_ll = Canvas[XY(left,           bot,            CanvasSize.x)].volume;
        uint vol_b =  Canvas[XY(canvas_pixel.x, bot,            CanvasSize.x)].volume;
        uint vol_lr = Canvas[XY(right,          bot,            CanvasSize.x)].volume;

        // ... ... sobel calculation
        int normal_x = -1 * vol_ul            + 1 * vol_ur
                     + -2 * vol_l             + 2 * vol_r
                     + -1 * vol_ll            + 1 * vol_lr;

        int normal_y = -1 * vol_ul + -2 * vol_u + -1 * vol_ur

                     +  1 * vol_ll +  2 * vol_b +  1 * vol_lr;

        int normal_z = 1;

        // ... ... scaling and normal assembly
        float scale = 0.0000025f;
        
        float4 normal = float4(scale * (float)normal_x, scale * (float)(-normal_y), normal_z, 1);
        float4 normalized = normalize(normal);
        float4 halfed = (normalized + float4(1, 1, 1, 1)) / 2;
        halfed.w = 1;

        NormalMap[canvas_pixel] = halfed;

        // update normal
        // Color c = new Color(halfed.x, halfed.y, halfed.z);
        // uint source_for_filter00 = 0;
        // uint source_for_filter10 = 0;
        // uint source_for_filter20 = 0;

        // uint source_for_filter01 = 0;
        // uint source_for_filter11 = 0;
        // uint source_for_filter21 = 0;

        // uint source_for_filter02 = 0;
        // uint source_for_filter12 = 0;
        // uint source_for_filter22 = 0;

        // calculate sources for sobel calculation
        // if (x == 0 && y == 0) // lower left special case
        // {
        //     source_for_filter00 = PaintReservoir.Get(0, 0).Volume;
        //     source_for_filter10 = PaintReservoir.Get(0, 0).Volume;
        //     source_for_filter20 = PaintReservoir.Get(0, 1).Volume;

        //     source_for_filter01 = PaintReservoir.Get(0, 0).Volume;
        //     source_for_filter11 = PaintReservoir.Get(0, 0).Volume;
        //     source_for_filter21 = PaintReservoir.Get(0, 1).Volume;

        //     source_for_filter02 = PaintReservoir.Get(0, 1).Volume;
        //     source_for_filter12 = PaintReservoir.Get(0, 2).Volume;
        //     source_for_filter22 = PaintReservoir.Get(1, 1).Volume;
        // }
        // else // normal case
        // {
            // source_for_filter00 = PaintReservoir.Get(x - 1, y - 1).Volume;
            // source_for_filter10 = PaintReservoir.Get(x,     y - 1).Volume;
            // source_for_filter20 = PaintReservoir.Get(x + 1, y - 1).Volume;

            // source_for_filter01 = PaintReservoir.Get(x - 1, y).Volume;
            // source_for_filter11 = PaintReservoir.Get(x,     y).Volume;
            // source_for_filter21 = PaintReservoir.Get(x + 1, y).Volume;

            // source_for_filter02 = PaintReservoir.Get(x - 1, y + 1).Volume;
            // source_for_filter12 = PaintReservoir.Get(x,     y + 1).Volume;
            // source_for_filter22 = PaintReservoir.Get(x + 1, y + 1).Volume;
        // }


        // // do sobel calculation
        // int normal_x = -1 * source_for_filter20 + 1 * source_for_filter22
        //              + -2 * source_for_filter10 + 2 * source_for_filter12
        //              + -1 * source_for_filter00 + 1 * source_for_filter02;

        // int normal_y = -1 * source_for_filter20 + -2 * source_for_filter21 + -1 * source_for_filter22
        //              +  1 * source_for_filter00 +  2 * source_for_filter01 +  1 * source_for_filter02;

        // int normal_z = 1;

        // float scale = 0.025f;
        // // calculate normal
        // Vector3 normal = new Vector3(scale * normal_x, scale * - normal_y, normal_z);/// 2 + new Vector3(0.5f, 0.5f, 0.5f);
        // Vector3 normalized = normal.normalized;
        // Vector3 halfed = (normalized + new Vector3(1, 1, 1)) / 2;

        // // update normal
        // Color c = new Color(halfed.x, halfed.y, halfed.z);
        // //Debug.Log("old normal was" + NormalMap.GetPixelFast(texture_x, texture_y));
        // //Debug.Log("new normal is" + c);
        // NormalMap.SetPixelFast(x, y, c);

    }
    // if (id.x == 0 && id.y == 0)
    // {
    //     Finished[0] = 1;
    // }
}